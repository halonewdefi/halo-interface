{"ast":null,"code":"'use strict';\n\nconst parseMilliseconds = require('parse-ms');\n\nconst pluralize = (word, count) => count === 1 ? word : `${word}s`;\n\nconst SECOND_ROUNDING_EPSILON = 0.0000001;\n\nmodule.exports = function (milliseconds) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!Number.isFinite(milliseconds)) {\n    throw new TypeError('Expected a finite number');\n  }\n\n  if (options.colonNotation) {\n    options.compact = false;\n    options.formatSubMilliseconds = false;\n    options.separateMilliseconds = false;\n    options.verbose = false;\n  }\n\n  if (options.compact) {\n    options.secondsDecimalDigits = 0;\n    options.millisecondsDecimalDigits = 0;\n  }\n\n  const result = [];\n\n  const floorDecimals = (value, decimalDigits) => {\n    const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);\n    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;\n    return flooredValue.toFixed(decimalDigits);\n  };\n\n  const add = (value, long, short, valueString) => {\n    if ((result.length === 0 || !options.colonNotation) && value === 0 && !(options.colonNotation && short === 'm')) {\n      return;\n    }\n\n    valueString = (valueString || value || '0').toString();\n    let prefix;\n    let suffix;\n\n    if (options.colonNotation) {\n      prefix = result.length > 0 ? ':' : '';\n      suffix = '';\n      const wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;\n      const minLength = result.length > 0 ? 2 : 1;\n      valueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n    } else {\n      prefix = '';\n      suffix = options.verbose ? ' ' + pluralize(long, value) : short;\n    }\n\n    result.push(prefix + valueString + suffix);\n  };\n\n  const parsed = parseMilliseconds(milliseconds);\n  add(Math.trunc(parsed.days / 365), 'year', 'y');\n  add(parsed.days % 365, 'day', 'd');\n  add(parsed.hours, 'hour', 'h');\n  add(parsed.minutes, 'minute', 'm');\n\n  if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1000) {\n    add(parsed.seconds, 'second', 's');\n\n    if (options.formatSubMilliseconds) {\n      add(parsed.milliseconds, 'millisecond', 'ms');\n      add(parsed.microseconds, 'microsecond', 'µs');\n      add(parsed.nanoseconds, 'nanosecond', 'ns');\n    } else {\n      const millisecondsAndBelow = parsed.milliseconds + parsed.microseconds / 1000 + parsed.nanoseconds / 1e6;\n      const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === 'number' ? options.millisecondsDecimalDigits : 0;\n      const roundedMiliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);\n      const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMiliseconds;\n      add(Number.parseFloat(millisecondsString, 10), 'millisecond', 'ms', millisecondsString);\n    }\n  } else {\n    const seconds = milliseconds / 1000 % 60;\n    const secondsDecimalDigits = typeof options.secondsDecimalDigits === 'number' ? options.secondsDecimalDigits : 1;\n    const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n    const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\\.0+$/, '');\n    add(Number.parseFloat(secondsString, 10), 'second', 's', secondsString);\n  }\n\n  if (result.length === 0) {\n    return '0' + (options.verbose ? ' milliseconds' : 'ms');\n  }\n\n  if (options.compact) {\n    return result[0];\n  }\n\n  if (typeof options.unitCount === 'number') {\n    const separator = options.colonNotation ? '' : ' ';\n    return result.slice(0, Math.max(options.unitCount, 1)).join(separator);\n  }\n\n  return options.colonNotation ? result.join('') : result.join(' ');\n};","map":{"version":3,"sources":["/home/augustin/vader-dapp/node_modules/pretty-ms/index.js"],"names":["parseMilliseconds","require","pluralize","word","count","SECOND_ROUNDING_EPSILON","module","exports","milliseconds","options","Number","isFinite","TypeError","colonNotation","compact","formatSubMilliseconds","separateMilliseconds","verbose","secondsDecimalDigits","millisecondsDecimalDigits","result","floorDecimals","value","decimalDigits","flooredInterimValue","Math","floor","flooredValue","round","toFixed","add","long","short","valueString","length","toString","prefix","suffix","wholeDigits","includes","split","minLength","repeat","max","push","parsed","trunc","days","hours","minutes","seconds","microseconds","nanoseconds","millisecondsAndBelow","roundedMiliseconds","ceil","millisecondsString","parseFloat","secondsFixed","secondsString","keepDecimalsOnWholeSeconds","replace","unitCount","separator","slice","join"],"mappings":"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","sourcesContent":["'use strict';\nconst parseMilliseconds = require('parse-ms');\n\nconst pluralize = (word, count) => count === 1 ? word : `${word}s`;\n\nconst SECOND_ROUNDING_EPSILON = 0.0000001;\n\nmodule.exports = (milliseconds, options = {}) => {\n\tif (!Number.isFinite(milliseconds)) {\n\t\tthrow new TypeError('Expected a finite number');\n\t}\n\n\tif (options.colonNotation) {\n\t\toptions.compact = false;\n\t\toptions.formatSubMilliseconds = false;\n\t\toptions.separateMilliseconds = false;\n\t\toptions.verbose = false;\n\t}\n\n\tif (options.compact) {\n\t\toptions.secondsDecimalDigits = 0;\n\t\toptions.millisecondsDecimalDigits = 0;\n\t}\n\n\tconst result = [];\n\n\tconst floorDecimals = (value, decimalDigits) => {\n\t\tconst flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);\n\t\tconst flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);\n\t\treturn flooredValue.toFixed(decimalDigits);\n\t};\n\n\tconst add = (value, long, short, valueString) => {\n\t\tif ((result.length === 0 || !options.colonNotation) && value === 0 && !(options.colonNotation && short === 'm')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalueString = (valueString || value || '0').toString();\n\t\tlet prefix;\n\t\tlet suffix;\n\t\tif (options.colonNotation) {\n\t\t\tprefix = result.length > 0 ? ':' : '';\n\t\t\tsuffix = '';\n\t\t\tconst wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;\n\t\t\tconst minLength = result.length > 0 ? 2 : 1;\n\t\t\tvalueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n\t\t} else {\n\t\t\tprefix = '';\n\t\t\tsuffix = options.verbose ? ' ' + pluralize(long, value) : short;\n\t\t}\n\n\t\tresult.push(prefix + valueString + suffix);\n\t};\n\n\tconst parsed = parseMilliseconds(milliseconds);\n\n\tadd(Math.trunc(parsed.days / 365), 'year', 'y');\n\tadd(parsed.days % 365, 'day', 'd');\n\tadd(parsed.hours, 'hour', 'h');\n\tadd(parsed.minutes, 'minute', 'm');\n\n\tif (\n\t\toptions.separateMilliseconds ||\n\t\toptions.formatSubMilliseconds ||\n\t\t(!options.colonNotation && milliseconds < 1000)\n\t) {\n\t\tadd(parsed.seconds, 'second', 's');\n\t\tif (options.formatSubMilliseconds) {\n\t\t\tadd(parsed.milliseconds, 'millisecond', 'ms');\n\t\t\tadd(parsed.microseconds, 'microsecond', 'µs');\n\t\t\tadd(parsed.nanoseconds, 'nanosecond', 'ns');\n\t\t} else {\n\t\t\tconst millisecondsAndBelow =\n\t\t\t\tparsed.milliseconds +\n\t\t\t\t(parsed.microseconds / 1000) +\n\t\t\t\t(parsed.nanoseconds / 1e6);\n\n\t\t\tconst millisecondsDecimalDigits =\n\t\t\t\ttypeof options.millisecondsDecimalDigits === 'number' ?\n\t\t\t\t\toptions.millisecondsDecimalDigits :\n\t\t\t\t\t0;\n\n\t\t\tconst roundedMiliseconds = millisecondsAndBelow >= 1 ?\n\t\t\t\tMath.round(millisecondsAndBelow) :\n\t\t\t\tMath.ceil(millisecondsAndBelow);\n\n\t\t\tconst millisecondsString = millisecondsDecimalDigits ?\n\t\t\t\tmillisecondsAndBelow.toFixed(millisecondsDecimalDigits) :\n\t\t\t\troundedMiliseconds;\n\n\t\t\tadd(\n\t\t\t\tNumber.parseFloat(millisecondsString, 10),\n\t\t\t\t'millisecond',\n\t\t\t\t'ms',\n\t\t\t\tmillisecondsString\n\t\t\t);\n\t\t}\n\t} else {\n\t\tconst seconds = (milliseconds / 1000) % 60;\n\t\tconst secondsDecimalDigits =\n\t\t\ttypeof options.secondsDecimalDigits === 'number' ?\n\t\t\t\toptions.secondsDecimalDigits :\n\t\t\t\t1;\n\t\tconst secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n\t\tconst secondsString = options.keepDecimalsOnWholeSeconds ?\n\t\t\tsecondsFixed :\n\t\t\tsecondsFixed.replace(/\\.0+$/, '');\n\t\tadd(Number.parseFloat(secondsString, 10), 'second', 's', secondsString);\n\t}\n\n\tif (result.length === 0) {\n\t\treturn '0' + (options.verbose ? ' milliseconds' : 'ms');\n\t}\n\n\tif (options.compact) {\n\t\treturn result[0];\n\t}\n\n\tif (typeof options.unitCount === 'number') {\n\t\tconst separator = options.colonNotation ? '' : ' ';\n\t\treturn result.slice(0, Math.max(options.unitCount, 1)).join(separator);\n\t}\n\n\treturn options.colonNotation ? result.join('') : result.join(' ');\n};\n"]},"metadata":{},"sourceType":"script"}